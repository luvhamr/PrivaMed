stages:
  - test
  - build
  - deploy

variables:
  # Tag images with short commit SHA
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"

# 1) Basic test/build sanity for Node + Truffle + frontend/backend deps
test_app:
  stage: test
  image: node:20-bullseye
  tags:
    - privamed
  script:
    # Root (Truffle etc.) â€“ ignore optional deps like fsevents on Linux
    - npm install --omit=optional
    - npx truffle compile

    # Backend deps
    - cd backend
    - npm install --omit=optional
    - cd ..

    # Frontend deps
    - cd client
    - npm install --omit=optional
    - cd ..
  rules:
    - if: '$CI_COMMIT_BRANCH'   # run on any branch

# 2) Build & push Docker images to GitLab registry
build_images:
  stage: build
  needs: [test_app]
  image: docker:25.0.3
  services:
    - name: docker:25.0.3-dind
      alias: docker
  tags:
    - privamed
  variables:
    # Tell docker CLI to talk to the dind service
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
  script:
    # Login to GitLab container registry
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

    # Build backend image
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$IMAGE_TAG" -f backend/Dockerfile .

    # Build client image, passing backend URL
    - docker build --build-arg REACT_APP_BACKEND_URL="$PUBLIC_BACKEND_URL" -t "$CI_REGISTRY_IMAGE/client:$IMAGE_TAG" -f client/Dockerfile .

    # Push images
    - docker push "$CI_REGISTRY_IMAGE/backend:$IMAGE_TAG"
    - docker push "$CI_REGISTRY_IMAGE/client:$IMAGE_TAG"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'   # only build images on main

# 3) Deploy to VM2 via SSH + docker compose
deploy_prod:
  stage: deploy
  needs: [build_images]
  image: alpine:3.20
  tags:
    - privamed
  before_script:
    # SSH client so we can talk to VM2
    - apk add --no-cache openssh-client

    # SSH agent & key setup
    - eval "$(ssh-agent -s)"
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh

    # Decode base64 private key from CI var SSH_PRIVATE_KEY_B64 into a file
    - echo "$SSH_PRIVATE_KEY_B64" | base64 -d > /tmp/privamed_ci
    - chmod 600 /tmp/privamed_ci
    - ssh-add /tmp/privamed_ci

    # Add VM2 host key to known_hosts to satisfy StrictHostKeyChecking
    - ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "Deploying to $DEPLOY_HOST as $DEPLOY_USER"

    # Ensure deploy directory exists on VM2
    - ssh -o StrictHostKeyChecking=yes "$DEPLOY_USER@$DEPLOY_HOST" "mkdir -p ~/privamed"

    # Copy compose file to VM2
    - scp -o StrictHostKeyChecking=yes docker-compose.app.yml "$DEPLOY_USER@$DEPLOY_HOST:~/privamed/"

    # Login to registry and docker-compose pull + up -d on VM2
    - |
      ssh -o StrictHostKeyChecking=yes "$DEPLOY_USER@$DEPLOY_HOST" "
        echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" $CI_REGISTRY &&
        IMAGE_TAG=$IMAGE_TAG CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE PUBLIC_BACKEND_URL=$PUBLIC_BACKEND_URL \
        docker compose -f ~/privamed/docker-compose.app.yml pull &&
        IMAGE_TAG=$IMAGE_TAG CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE PUBLIC_BACKEND_URL=$PUBLIC_BACKEND_URL \
        docker compose -f ~/privamed/docker-compose.app.yml up -d
      "
  environment:
    name: production
    url: "http://$DEPLOY_HOST:3000"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
